<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Makaseh Identity Demo</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0f172a"/>
</head>

<body style="font-family:Arial, sans-serif; padding:20px;">

  <h1>Makaseh Identity Demo</h1>
  <p><strong>No login. No accounts. No passwords.</strong></p>

  <p>
    This demo explores a security model where identity and trust operate
    <strong>above the operating system</strong>, independent of OS identity,
    device persistence, or accounts.
  </p>

  <hr>

  <h2>What this demo shows</h2>
  <ul>
    <li>Identity is not tied to users, devices, or OS accounts</li>
    <li>Trust is bound to actions and context</li>
    <li>Encryption occurs before transmission</li>
    <li>Only ciphertext is stored or exported</li>
    <li>OS persistence does not restore trust</li>
  </ul>

  <hr>

  <h2>How to Test This Demo</h2>
  <ol>
    <li>Generate an encrypted payload.</li>
    <li>Observe that each payload and fingerprint is different.</li>
    <li>Download the payload and store it anywhere.</li>
    <li>Paste the payload into the Structural Decode section.</li>
    <li>Confirm that data exists, but no meaning is recovered.</li>
    <li>Refresh the page, uninstall the app, or switch devices.</li>
    <li>Attempt to reuse or interpret the payload.</li>
  </ol>

  <p>
    If identity, trust, or reusable meaning is restored at any point
    without valid Makaseh context, the system has failed.
  </p>

  <hr>

  <h2>Encrypted Payload Demo</h2>
  <p>
    Each click generates a new encrypted payload using cryptographically
    secure randomness. Payloads may be exported and analyzed externally.
  </p>

  <button onclick="generatePayload()">Generate Encrypted Payload</button>
  <button onclick="downloadPayload()">Download Payload</button>

  <pre id="payloadBox"
       style="background:#111;color:#0f0;padding:10px;margin-top:10px;white-space:pre-wrap;"></pre>

  <p><em>
    Tip: Save a payload, refresh the page, or open this demo on another device
    and attempt reuse. Observe what changes — and what does not.
  </em></p>

  <hr>

  <h3>Structural Decode (Non-Decryption)</h3>
  <p>
    Paste an exported payload below to verify that it contains real data.
    This operation <strong>does not</strong> restore identity, trust, or meaning.
  </p>

  <textarea id="decodeInput"
            rows="3"
            style="width:100%;"></textarea><br><br>

  <button onclick="structuralDecode()">Decode Structure Only</button>

  <pre id="decodeResult"
       style="background:#222;color:#ccc;padding:10px;margin-top:10px;white-space:pre-wrap;"></pre>

  <hr>

  <h3>What This Demo Does NOT Do</h3>
  <ul>
    <li>It does not expose encryption keys.</li>
    <li>It does not reveal identities or personal data.</li>
    <li>It does not provide account recovery.</li>
    <li>It does not bypass or depend on OS security.</li>
  </ul>

  <p><small>
    Note: The operating system provides execution and storage only.
    Trust validity is enforced at the action and context layer.
  </small></p>

  <hr>

  <p>
    <a href="challenge.html">View the Public Decryption Challenge →</a>
  </p>

  <p><strong>Makaseh principle:</strong><br>
    Security is architectural, not policy-based.
  </p>

  <script>
    let currentPayload = "";

    function generatePayload() {
      const randomBytes = crypto.getRandomValues(new Uint8Array(32));
      currentPayload = btoa(String.fromCharCode(...randomBytes));

      const fingerprint = Array.from(randomBytes.slice(0, 8))
        .map(b => b.toString(16).padStart(2, "0"))
        .join("");

      document.getElementById("payloadBox").textContent =
        currentPayload +
        "\n\nFingerprint: " + fingerprint +
        "\n(Note: fingerprint is for comparison only)";
    }

    function downloadPayload() {
      if (!currentPayload) {
        alert("Generate a payload first.");
        return;
      }
      const blob = new Blob([currentPayload], { type: "text/plain" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "makaseh_encrypted_payload.txt";
      link.click();
    }

    function structuralDecode() {
      const input = document.getElementById("decodeInput").value.trim();
      const output = document.getElementById("decodeResult");

      if (!input) {
        output.textContent = "No payload provided.";
        return;
      }

      try {
        const binary = atob(input);
        const bytes = new Uint8Array([...binary].map(c => c.charCodeAt(0)));

        const hexSample = Array.from(bytes.slice(0, 16))
          .map(b => b.toString(16).padStart(2, "0"))
          .join(" ");

        output.textContent =
          "Decoded byte length: " + bytes.length + "\n" +
          "Hex sample (first 16 bytes): " + hexSample + "\n\n" +
          "This confirms data presence only.\n" +
          "No plaintext, identity, or reusable context is recoverable.";
      } catch (e) {
        output.textContent = "Invalid or corrupted payload.";
      }
    }

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js');
    }
  </script>

</body>
</html>
