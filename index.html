<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Makaseh Identity Demo</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0f172a"/>
</head>

<body style="font-family:Arial, sans-serif; padding:20px;">

  <h1>Makaseh Identity Demo</h1>
  <p><strong>No login. No accounts. No passwords.</strong></p>

  <h2>What this demo shows</h2>
  <ul>
    <li>Identity operates above the operating system</li>
    <li>Trust is bound to actions, not users or devices</li>
    <li>Encryption occurs before transmission</li>
    <li>Only ciphertext is stored or exported</li>
    <li>OS persistence does not restore trust</li>
  </ul>

  <hr>

  <h2>Encrypted Payload Demo</h2>
  <p>
    Each click generates a new encrypted payload.
    Payloads can be exported and tested externally.
  </p>

  <button onclick="generatePayload()">Generate Encrypted Payload</button>
  <button onclick="downloadPayload()">Download Payload</button>

  <pre id="payloadBox"
       style="background:#111;color:#0f0;padding:10px;margin-top:10px;white-space:pre-wrap;"></pre>

  <p><em>
    Without a valid Makaseh context, payloads carry no reusable meaning.
  </em></p>

  <hr>

  <h3>Structural Decode (Non-Decryption)</h3>
  <p>
    Paste an exported payload below to verify that it contains data.
    This operation does <strong>not</strong> restore identity, trust, or meaning.
  </p>

  <textarea id="decodeInput"
            rows="3"
            style="width:100%;"></textarea><br><br>

  <button onclick="structuralDecode()">Decode Structure Only</button>

  <pre id="decodeResult"
       style="background:#222;color:#ccc;padding:10px;margin-top:10px;white-space:pre-wrap;"></pre>

  <hr>

  <p>
    <a href="challenge.html">View the Public Decryption Challenge â†’</a>
  </p>

  <p><strong>Makaseh principle:</strong><br>
    Security is architectural, not policy-based.
  </p>

  <script>
    let currentPayload = "";

    function generatePayload() {
      // cryptographically secure random bytes
      const randomBytes = crypto.getRandomValues(new Uint8Array(32));

      // Base64 encode
      currentPayload = btoa(String.fromCharCode(...randomBytes));

      // simple non-sensitive fingerprint (first 8 bytes)
      const fingerprint = Array.from(randomBytes.slice(0, 8))
        .map(b => b.toString(16).padStart(2, "0"))
        .join("");

      document.getElementById("payloadBox").textContent =
        currentPayload +
        "\n\nFingerprint: " + fingerprint +
        "\n(Note: fingerprint is for comparison only)";
    }

    function downloadPayload() {
      if (!currentPayload) {
        alert("Generate a payload first.");
        return;
      }
      const blob = new Blob([currentPayload], { type: "text/plain" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "makaseh_encrypted_payload.txt";
      link.click();
    }

    function structuralDecode() {
      const input = document.getElementById("decodeInput").value.trim();
      const output = document.getElementById("decodeResult");

      if (!input) {
        output.textContent = "No payload provided.";
        return;
      }

      try {
        const binary = atob(input);
        const bytes = new Uint8Array([...binary].map(c => c.charCodeAt(0)));

        const hexSample = Array.from(bytes.slice(0, 16))
          .map(b => b.toString(16).padStart(2, "0"))
          .join(" ");

        output.textContent =
          "Decoded byte length: " + bytes.length + "\n" +
          "Hex sample (first 16 bytes): " + hexSample + "\n\n" +
          "This confirms data presence only.\n" +
          "No plaintext, identity, or reusable context is recoverable.";
      } catch (e) {
        output.textContent = "Invalid or corrupted payload.";
      }
    }

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js');
    }
  </script>

</body>
</html>
